---
title: Почему я не использую CSS nesting и вам не советую
layout: post
tags: [веб, css, nesting, бэм,]
thumbnail: 
---
В Хроме и бете Сафари (на момент написания) [появился](https://caniuse.com/css-nesting) нативный CSS nesting, то есть возможность вкладывать одни css правила в другие, подобно тому, как это позволяют делать препроцессоры вроде Sass. О том, почему я не большой поклонник этой фичи читайте далее:)

CSS нестинг противоречит практике разделения разметки/структуры HTML и стилизации CSS (что в свою очередь увеличивает связанность кода), делает код менее читаемым и решает задачи, которые уже решают другие подходы без вышеперечисленных проблем. Давайте разберем каждый пункт.

## Связанность
Про связанность кода часто говорят в контексте внутри самого CSS, когда речь идет об использовании слишком общих селекторов по элементам и вложенности селекторов. Например, селектор ```.some-list a``` может выглядеть безобидно сегодня, но завтра окажется, что в каждом пункте меню не один тип ссылок, а несколько.

Примерно та же проблема возникает, когда мы тянем структуру страницы из HTML в CSS. Посмотрим на [пример](https://webkit.org/blog/13813/try-css-nesting-today-in-safari-technology-preview/) от создателей <del>нового Internet Explorer</del> Safari:

![скриншот кода](/Images/css-nesting-1.png)

Предполагается, что у нас есть некий компонент со списком внутри. Мы хотим задать внутренний отступ всем спискам и убрать отступ по умолчанию у списка внутри компонента.

Я вижу сразу несколько проблем предлагаемого решения:

1. У списка компонента нет класса. Это может привести к проблемам в будущем. Если что-то поменяется в структуре (в компоненте появится другой список) придется переписывать правило. Но если бы у этих списков был свой класс вся эта конструкция была бы не нужна в принципе (заглянувшие в теги могут догадаться к чему я веду:)
2. Из этого css непонятно, можно ли будет использовать этот список вне компонента. Если да, то опять же это создаст дополнительную работу. Подробнее о решении этой проблемы по БЭМу можно [почитать в доках](https://ru.bem.info/methodology/solved-problems/#%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B0%D1%87%D0%B0%D1%82%D1%8C-%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D0%BD%D0%BE-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BA%D0%BE%D0%B4-%D0%B8-%D0%B8%D0%B7%D0%B1%D0%B5%D0%B6%D0%B0%D1%82%D1%8C-%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%B4%D1%80%D1%83%D0%B3-%D0%BD%D0%B0-%D0%B4%D1%80%D1%83%D0%B3%D0%B0).

Тут стоит отметить, что хотя БЭМ допускает применение каскада, но не рекомендуется использовать его без крайней необходимости. Нестинг же по сути построен на предположении, что каскад через вложенные селекторы используется регулярно.

## Читаемость

При использовании нестинга (с любой реализацией и не только в этом примере), страдает читаемость кода. В обычном CSS правиле есть только два уровня индентации. Верхний с селектором и внутренний со свойствами. Это позволяет минимально напрягая мозг и максимально быстро пробежать по коду, считать и найти нужное. А что с нестингм?

1. С нестингом вы не знаете заранее, что именно будет стоять на внутреннем отступе: свойство или селектор. Конечно это отчасти решается подсветкой синтаксиса, но сокращает способы считываемости.
2. Кроме того вложенность может обозначаться в любую сторону. Что еще больше увеличивает нагрузку на мозг.
3. А еще можно вкладывать многоуровеневые медиа-запросы. Посмотрите на этот ужас из спецификации:

![](/Images/css-nesting-2.png)

Представьте, что вам нужно убарть правило для ориентации экрана, но оставить для ширины)

В целом не вижу причин не следовать и здесь золотому правилу "не усложняйте без необходимости".

## Решение

Решение всех этих и многих других проблем уже давно известно и многими в разной форме используется. Это методологии именования классов. Одна из них БЭМ, которую я использую и могу посоветовать вам. Впрочем, какую именно методолгию использовать не так важно, как принципы, на которые они обычно опираются. 

Один из таких принципов - давать уникальные классы всем уникальным сущностям. Я не буду здесь углубляться в то, как именно это делается по БЭМу вы можете почитать про это сами [по ссылкам в моей подборке](https://vallek.github.io/web-links/#bem) или даже попасть на [мою лекцию](https://vallek.github.io/Portfolio/pages/projects/bem.html), если она проводится. 

Но пока просто предлагаю сравнить два примера:

<pre>
	ul {
	  padding-left: 1em;
	  .component & {
	    padding-left: 0;
	  }
	}
</pre>


<pre>
	ul {
		padding-left: 1em;
	}
	.component__list {
		padding-left: 0;
	}
</pre>

Какой из них проще понять? 

"А как же правило для всех списков?" - спросите вы - "это ведь не по БЭМу". Да, таких общих стилей лучше избегать. Но, если речь идет об одном селекторе по тегу, то правила с классом его перепишут, так что это не самое страшное, что можно сделать. В целом же БЭМ это не высеченные в граните заповеди, а принципы. Они могут принести пользу, но только, если перед их использовнием подумать, что и зачем вы делаете. 

Но главное отличие этих подходов с моей точки зрения можно выразить так: нестинг тащит структуру в стили, методология же следует структуре и задачам. Поэтому с БЭМом парадоксальнее проще понять, о какой структуре идет речь, не заглядывая в html. Ведь классы описывают ее семантически. 

Конечно, нет смысла использовать БЭМ, не думая заранее, что и где нужно будет переиспользовать. И, да, задачи могут поменяться. Но рефакторить элементы в блоки, по-моему полегче, чем пытаться переиспользовать вот это чудо:

![](/Images/css-nesting-3.png)